Данный код представляет собой игру на базе Pygame, которая решает задачу поиска кратчайшего пути в лабиринте с использованием различных алгоритмов. Давайте разберем функциональность этого кода в контексте критериев 8-го задания, включая добавление таймера, вывод результатов и визуализацию путей:

### 1. **Инициализация и настройки:**
- **Pygame:** Инициализация библиотеки Pygame для работы с графикой и управлениями окнами.
- **Размеры окна и лабиринта:** Устанавливаются размеры окна (600x600 пикселей) и сетки (5x5), каждая ячейка имеет размер 120x120 пикселей.
- **Цвета:** Задаются различные цвета для стен, цели, пути, а также для отображения алгоритмов (BFS, A*, Dijkstra, Greedy и Wave).

### 2. **Лабиринты:**
- **Массив лабиринтов:** Программа включает 5 различных лабиринтов размером 5x5, представленных в виде двумерных массивов (где `0` — пустая ячейка, а `1` — стена).

### 3. **Основная функция (`main`):**
- Окно Pygame создается с размерами 600x600.
- Для каждого лабиринта выполняются следующие действия:
  - **Отображение лабиринта:** Визуализация каждой ячейки лабиринта с помощью прямоугольников.
  - **Отображение стартовой и конечной точки:** Начальная точка отображается зеленым цветом, конечная — голубым.
  - **Запуск алгоритмов поиска пути:** Для каждого лабиринта запускаются алгоритмы поиска пути: BFS, A*, Dijkstra, Greedy и Wave.
  - **Отображение путей:** Путь, найденный каждым алгоритмом, отображается на экране с использованием соответствующего цвета.
  - **Тайминг:** Время выполнения каждого алгоритма измеряется с использованием `time.perf_counter()`, и выводится в миллисекундах.

### 4. **Алгоритмы поиска пути:**
- **BFS (Поиск в ширину):** Используется очередь и отображаются соседние клетки. Обрабатываются все клетки поочередно.
- **A* (Алгоритм A*):** Использует эвристическую функцию для оценки расстояния до цели, что позволяет эффективно искать путь.
- **Dijkstra:** Алгоритм для поиска кратчайшего пути, используя наименьшее расстояние для выбора следующей клетки.
- **Greedy (Жадный алгоритм):** Стремится к цели, выбирая клетку, которая минимизирует эвристическую функцию.
- **Wave (Волновой алгоритм):** Использует очередь и изучает все клетки на уровне, до тех пор пока не достигнет цели.

### 5. **Результаты и сравнение:**
- Для каждого лабиринта после выполнения алгоритмов выводятся:
  - **Длина пути** для каждого алгоритма.
  - **Время выполнения** каждого алгоритма в миллисекундах.
  - Если путь найден, он отображается на экране.
- В конце программы производится итоговое сравнение для всех лабиринтов:
  - Средняя длина пути и среднее время выполнения для каждого алгоритма.

### 6. **Таймер и вывод в миллисекундах (Критерий 8):**
- **Таймер:** Время выполнения алгоритмов для каждого лабиринта измеряется в миллисекундах с использованием `time.perf_counter()` и выводится на экран.
- **Результаты:** После обработки всех лабиринтов, для каждого алгоритма выводятся усредненные результаты по длине пути и времени выполнения.

### Визуализация и взаимодействие:
- **Рисование лабиринтов и путей:** Каждый лабиринт рисуется с использованием прямоугольников для стен и свободных ячеек. Пути, найденные алгоритмами, отображаются с использованием различных цветов для различения алгоритмов.
- **Интерфейс:** После того как путь найден, на экране показывается путь, а также в консоли выводятся статистические данные о длине пути и времени работы алгоритма.

### Заключение:
Этот код полностью удовлетворяет критериям задания:
- **Отображение нескольких алгоритмов** и сравнение их результатов.
- **Измерение времени выполнения** алгоритмов с точностью до миллисекунд.
- **Визуализация найденных путей** с использованием различных цветов для различных алгоритмов.
- **Сравнение алгоритмов** по нескольким лабиринтам, вывод усредненных результатов.

В нем добавлен таймер, который выполняет свою задачу с точностью в миллисекундах, что соответствует требованиями задания, и выводит все результаты на экран и в консоль для анализа эффективности алгоритмов.
